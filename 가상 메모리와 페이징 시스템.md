# 가상 메모리 개념 이해

### 가상 메모리가 필요한 이유

- 배치처리 시스템 같이 하나의 프로세스만 실행 가능한 시스템에선 가상 메모리가 필요 없음
- 하지만 우리는 여러 프로세스를 동시에 실행하는 시스템을 사용중
    - 메모리 용량 부족 이슈
    - 프로세스 메모리 영역간에 침범 이슈

### 가상메모리

- 메모리가 실제 메모리보다 많아 보이게 하는 기술
    - 실제 사용하는 메모리는 작다는 점에 착안해서 고안된 기술
    - 프로세스간 공간 분리로, 프로세스 이슈가 전체 시스템에 영향을 주지 않을 수 있음
- 기본 아이디어
    - 프로세스는 가상 주소를 사용하고, 실제 해당 주소에서 데이터를 읽고/쓸때만 물리 주소로 바꿔줌
    - 가상 주소 : 프로세스가 참조하는 주소
    - 물리 주소 : 실제 메모리 주소
- MMU
    - CPU에 코드 실행시, 가상 주소 메모리 접근이 필요할 때, 해당 주소를 물리 주소값으로 변환해주는 하드웨어 장치
    - CPU는 가상 주소만 가지고 호출을 하고, MMU가 전담으로 물리 메모리 처리를 한다.

---

## 페이징 시스템

### 페이징

- 크기가 동일한 페이지로 가상 주소 공간과 이에 매칭하는 물리 주소 공간을 관리
    - 아무 의미 없이 크기만 동일하게 자른다.
- 하드웨어 지원이 필요함
- 리눅스에서는 4KB로 페이징
- 페이지 번호를 기반으로 가상 주소/물리 주소 매핑 정보를 기록/사용

### 페이징 시스템 구조

- page 또는 page frame : 고정된 크기의 block(4KB)
- 페이징 시스템
    - 가상 주소 v = (p, d)
        - p : 가상 메모리 페이지
        - d : p 안에서 참조하는 위치(변위)

### 페이지 테이블

- 물리 주소에 있는 페이지 번호와 해당 페이지의 첫 물리 주소 정보를 매핑한 표
- 페이징 시스템 동작
    - 해당 프로세스에서 특정 가상 주소 엑세스를 하려면
        - 해당 프로세스의 페이지 테이블에 해당 가상 주소가 포함된 페이지 번호가 있는지 확인
        - 페이지 번호가 있으면 이 페이지가 매핑된 첫 물리 주소를 알아내고(p')
        - p’ + d 가 실제 물리 주소가 됨

### 참고 : 다중 단계 페이징 시스템

- 프로세스를 실행할 때 2의 20승 (약 100만개)의 페이지 정보가 필요함
    - 시간이 오래걸림
- 필요없는 페이지는 생성하지 않기 위해 페이지 정보를 단계를 나누어 생성
- 필요한 페이지 정보만 생성하여 공간 절약

---

### MMU와 TLB (컴퓨터 구조)

- MMU가 물리 주소를 확인하기 위해 메모리를 갔다와야 함
    1. CPU가 가상 주소로 MMU한테 데이터를 요청
    2. MMU가 CPU에 있는 CR3에서 해당 페이지 테이블을 확인
    3. 페이지 테이블에서 가상 주소에 매핑되는 물리 주소를 찾아서 접근
    4. 데이터를 가지고 CPU에 전달
- 이 과정들이 너무 복잡하고 오래걸려서
    - TLB에 MMU의 최근 행동들을 저장함
    - TLB : 페이지 정보 캐쉬

---

### 요구 페이징 (Demand paging 또는 Demanded paging)

- 프로세스 모든 데이터를 메모리로 적재하지 않고, 실행 중 필요한 시점에서만 메모리로 적재
    - 선행 페이징 : 미리 프로세스 관련 모든 데이터를 메모리에 올려놓고 실행
    - 더 이상 필요하지 않은 페이지 프레임은 다시 저장매체에 저장 (**페이지 교체 알고리즘 필요**)

### 페이지 폴트

- 어떤 페이지가 실제 물리 메모리에 없을 때 일어나는 인터럽트
- 운영체제가 페이지 폴트가 일어나면, 해당 페이지를 물리 메모리에 올림
- 페이지 폴트가 자주 일어나면?
    - 실행되기 전에, 해당 페이지를 물리 메모리에 올려야 함
        - 시간이 오래 걸림
- 페이지 폴트가 안나게 하려면?
    - 향후 실행/참조될 코드/데이터를 미리 물리 메모리에 올리면 됨
        - 앞으로 있을 일을 예측해야 함 - 신의 영역

### 인터럽트와 IDT

- 인터럽트는 미리 정의되어 각각 번호와 실행 코드를 가리키는 주소가 기록되어 있음
    - 어디에? IDT에 기록
    - 언제? 컴퓨터 부팅시 운영체제가 기록
    - 어떤 코드? 운영체제 내부 코드

### 페이지 교체 정책

- 운영체제가 툭종 패아자룰 물리 메모리에 올리려 하는데, 물리 메모리가 다 차있다면?
    - 기존 페이지 중 하나를 물리 메모리에서 저장 매체로 내리고
    - 새로운 페이지를 해당 물리 메모리 공간에 올린다
- 어떤 페이지를 물리 메모리에서 저장 매체로 내릴 것인가?

## 페이지 교체 알고리즘

### FIFO

- 가장 먼저 들어온 페이지를 내리자

### OPT

- 최적 페이지 교체 알고리즘
    - 앞으로 가장 오랫동안 사용하지 않을 페이지를 내리자
    - 일반 OS에서는 구현 불가

### LRU

- 가장 오래 전에 사용된 페이지를 교체
- OPT가 구현이 불가능하니까 과거 기록으로 구현을 시도

### LFU

- 가장 적게 사용된 페이지를 내리자

### LUR

- LRU와 마찬가지로 최근에 사용하지 않은 페이지부터 교체
- 각 페이지마자 참조 비트(R), 수정 비트(M)를 둠 (R, M)
    - (0, 0), (0, 1), (1, 0), (1, 1) 순으로 페이지 교체

<aside>
💡 스레싱 (Thrashing) : 반복적으로 페이지 폴트가 발생해서, 과도하게 페이지 교체 작업이 일어나, 실제로는 아무일도 하지 못하는 상황

</aside>
