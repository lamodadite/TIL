# 컴퓨터 구조

---

## 컴퓨터의 3대 구성 요소 이해

### 컴퓨터 시스템

- 하드웨어와 소프트웨어로 구성
- 주요 소프트웨어 : 운영체제와 응용 프로그램
- 주요 하드웨어 : CPU, Memoty, Storage, Network

### 폰 노이만 구조 (현 컴퓨터 구조)

- Memory에 프로그램과 데이터가 저장
- 폰 노이만 구조 이전엔 컴퓨터들은 다른 작업을 하려고 할때 하드웨어를 뜯어 고쳐야 했다.
- 폰 노이만 구조 이후엔 소프트웨어만 교체하면 된다.

### CPU

- 연산 - 산술 연산, 논리 연산
- 제어 - 입출력장치, ALU동작 제어

### Memory(코드와 데이터를 저장하는 장치)

- CPU 안에 레지스터, 캐쉬
- DRAM등 메모리 (램, RAM, DDR4)
- 외부기억장치 - SSD, HDD

### IO Devices(입출력 장치)

- 입력 장치 : 마우스, 키보드, 터치패드
- 출력 장치 : 모니터, 프린터, 스피커 등

### BUS

이 모든 장치들을 이어주는 연결 시스템

---

## 비트로 문자와 숫자 표현 이해

### 컴퓨터는 전기를 끄고, 키는 것만으로 작동한다!

- 즉, 0과 1만 가지고 우리는 컴퓨터와 의사소통을 할 수 있다. 0과 1로 이루어진 데이터를 우리는 **bit**라고 한다
- 비트와 연산

### 논리 연산

- AND, OR 연산자

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/be9645d9-710a-4d8c-8e2b-df6cc010cdec/Untitled.png)

- 직렬과 교류의 원리와도 같다.
- 논리연산이 가능한 회로를 구성할 수 있다.

### NOT Gate

- 결과값을 반대로 반환

### NAND와 NOR GATE

- AND와 OR의 결과값과 반대

### 부울 대수식

- 1 X 1 = 1 이니까, A = 1, B = 1 이면 AND는 AB로 A X B 처럼 생각해도 큰 무리가 없음

---

## 반가산기와 전가산기 동작 이해

### 반가산기

- 1 bit짜리 2진수 두 개를 덧셈한 합(S)과 자리올림수(C)를 구하는 조합논리회로
- XOR 와 AND 게이트를 사용하면 한 자리의 덧셈 가능

### 전가산기

- 뒷자리에서 올라온 자리올림수(Ci)를 포함하여 1bit짜리의 2진수 3자리를 더하여 합(Si)과 자리올림수(ci+1)을 구하는 회로
- 두 개의 반가산기와 한 개의 OR Gate로 구성되어 있음

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/6c9a308e-df9a-45d8-85ab-c1df7a87091c/Untitled.png)

---

## 16비트 가산기와 클럭 동작 이해

- 2비트 가산기를 병렬로 이어 8비트 가산기를 만들 수 있다.
- 같은 원리로 16비트 전가산기를 만들 수 있다. (2의 16승까지 덧셈 가능)
- 이렇게 데이터를 처리할 수 있는 범위가 계속해서 늘어간다.

### 클럭

- CPU : 2.5GHz ⇒ 1초에 1,000,000,000Hz 만큼의 클럭이 실행된다는 뜻
- 0과 1을 반복하는 주기
- 1이 켜질때마다 전체 시스템이 하나씩 실행을 한다.
- 때문에 시스템의 순서가 안맞거나 할 일은 없다.

---

## 플립플롭과 메모리 동작 이해

### 플립플롭

- 데이터를 저장하는 조합논리회로
- 첫 번째 스위치를 한 번이라도 켜면, 스위치를 꺼도 불은 계속 켜져있음
- 두 번째 스위치를 끄면 불이 꺼지고, 스위치를 꺼도 불은 꺼진채로 지속됨
- 즉, 데이터를 저장하고, 삭제할 수 있다!

### RS 플립플롭

- reset, set 스위치의 신호에 따라, 2진수 한 자리를 기억
- reset 스위치만 켜면 0을 기억
- set 스위치만 켜면 1을 기억
- 단, 두 스위치를 모두 켜면 아예 동작이 되지 않는다.
- 여기에 Hold That Bit라는 회로를 추가하면, 클럭과 연결되어 클럭이 1일때만 입력을 받는다.

### D-type 플립플롭

- input을 데이터 하나로 함
- 하나의 데이터를 저장할 수 있는 기본적인 회로가 된다.
- RS의 한계인 둘 다 1일 경우를 피하도록 설계됨
- 이를 1 bit latch라고 부른다.

---

## 8x1 메모리 동작과 구성 이해

이제 우리는 latch를 연결해서 8 bit 데이터도 저장이 가능하다!

### 8 to 1 selector

- 8개의 1 bit latch 중에서 하나의 데이터 출력 신호를 선택할 수 있음
- 3개의 selector input 스위치로 구분

### 3 to 8 decoder

- 원하는 위치에 데이터를 넣기 위한 회로
- v 스위치로 특정 출력을 선정하고, 데이터를 이 특정 latch에만 넣음

### RAM (Random Access Memory)

- 온전한 8 bit latch 회로 : 8 to 1 selector + 3 to 8 decoder
- 이를 우리는 RAM이라고 부른다.
- 8개중 하나의 비트를 선택해서 쓰거나, 읽을 수 있다.
- 특징 1 - 데이터를 저장
- 특징 2 - 특정 공간에 새로운 데이터 저장, 읽기 가능
- 특징 3 - address 지정을 통해 특정 공간 값 접근 가능

---

## 64K 메모리 동작과 구성 이해

## RAM array

- 8 x 1 RAM ⇒ 8개의 데이터를 저장하고 읽는데, 각 데이터는 1비트이다.
- 8 x 2 RAM ⇒ 8개의 데이터를 저장하고 읽는데, 각 데이터는 2비트이다.
- 16 x 1 RAM ⇒ 16개의 데이터를 저장하고 읽는데, 각 데이터는 1비트이다.

## m*n RAM array

- 8 x 1 RAM을 여러개 연결하고, 여러 개의 Select로 Decoder/Selector를 구성하면 많은 데이터를 읽고 저장할 수 있다.
- 10개의 Address와 8개의 DI ⇒ 1024 x 8 bits = 8196 bits를 다루는 RAM array 탄생

### 64K RAM

- 65,536(2의 16승) x 8 RAM
- 삼성에서 이를 상용화하며 한국의 반도체의 위상이 크게 올라간 상징적인 제품

---

## Accumulator 동작과 구성 이해

### Accumulator (가산기)

- 8-bit Adder 와 8-bit Latch로 구성
- 입력값을 연산하고 저장, clear하는 기능으로 구성됨
- 이 과정에서 필요한 임시저장공간을 레지스터, 캐쉬라고 한다.
- CPU가 저장메체에 가서 정보를 가져오는건 시간이 오래 걸리기 때문에, 이러한 임시 저장공간에 저장을 해놓는다.
- 메모리 계층 :  레지스터 → 캐쉬1 → 캐쉬2 → 캐쉬3 → 메모리(RAM) → SSD → HDD
- 이 순서대로 엑세스 시간이 길어진다.

---

## 레지스터와 프로그래밍 이해

### Instruction Set과 코드

- Software: Code + Data
    - Software Engineer : code를 작성하는 사람
    - Machine language : CPU는 Instruction code를 만들어놓고, 제공함
    - 컴파일: 프로그래밍 언어로 작성된 프로그램은 컴파일러를 통해 CPU가 제공하는 Instruction code를 기반으로 변환됨

### 컴퓨터의 CPU 기본 구조

- CPU에 레지스터라는 저장공간이 있음 - 빠른 실행을 위해
    - PC : 다음 실행할 명령어 주소를 가리키는 레지스터
    - IR : 가장 최근에 인출한 명령어 보관 레지스터
    - ACC : 데이터 일시 보관 레지스터
    - MAR : CPU가 메모리 참조를 위해 보관하는 데이터 주소를 가진 레지스터
    - MBR : CPU가 메모리로부터 읽거나, 저장할 데이터 자체를 보관하는 레지스터

---

## CPU 파이프라인의 이해

### 현 컴퓨터의 CPU 기본 실행 구조

1. Instruction Fetch : 실행할 명령어를 메모리에서 읽어 CPU로 가져옴
2. Instruction Decode : 인출한 명령어에 포함된 데이터 가져오고 명령어 해독
3. Instruction Execution : 명령어 실행
4. Write Back : 실행 결과를 저장

### CPU 파이프라인

- 파이프라인 : 하나의 작업에 필요한 일을 세부적으로 나누어서 동시에 다른 세부작업을 실행하는 기법
- 이를 구현하기 위해 작업을 세부적으로 나눔
- 더 세세하게 나눌수록 속도는 빨라짐
- 클럭이 한 번, 즉 cycle이 1일때 하나의 명령을 실행함
- 때문에 작업을 나눌수록 명령에 필요한 cycle은 늘어남

### 파이프라인을 알아야 하는 이유?

- 인텔의 보안상의 문제 이슈
- 이러한 이슈가 발생했을때, 파이프라인이 무엇인지 이해하고 있어야 올바른 선택을 내릴 수 있다!

---

## CISC, RISC CPU 이해와 컴퓨터 구조 정리

### CISC

- 하나의 명령어 실행으로 가능한 한 많은 작업을 수행 (복합 명령어)
- 명령어의 포맷이나 길이에 관한 규칙 없음
- 복합 명령어 수행을 위해 CPU 로직 회로 복잡도 증가
    - 하나의 명령어 실행 시간 증가
- 전체 명령이 얼마나 걸릴지 시간 예측 어려움

### RISC

- 간단한 명령어를 조합해서 실행하면 더 효율적이지 않을까?
- 코드가 더 길어질 수 있음
- 명령어의 포맷과 길이 고정
- 전체 명령 시간 예측 가능

<aside>
💡 당연히 둘 다 장단점이 있다.

</aside>

- 대표적인 CISC : 인텔
- 대표적인 RISC : ARM
    - 스마트폰, IOT 기기

---

### DMA

- CPU가 캐쉬까지는 데이터를 가져오는데 관여하지만
- 메모리, SSD에서 데이터를 가져오면 CPU 활용도가 낮아진다
    - 때문에 별도의 장치를 만들어서 CPU를 돕게 하고 이를 DMA라 한다.
